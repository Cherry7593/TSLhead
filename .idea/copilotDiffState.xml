<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/README.md">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/README.md" />
              <option name="originalContent" value="# TSL_Head - 玩家头颅插件&#10;&#10;![Version](https://img.shields.io/badge/version-1.0-blue.svg)&#10;![Minecraft](https://img.shields.io/badge/minecraft-1.21-green.svg)&#10;![Folia](https://img.shields.io/badge/folia-supported-orange.svg)&#10;&#10;一个用于 Minecraft 服务器的自定义玩家头颅生成插件，支持稀有度系统和离线玩家头颅获取。&#10;&#10;## ✨ 主要功能&#10;&#10;-  **自定义头颅生成** - 根据配置创建带有自定义名称和描述的玩家头颅&#10;-  **离线玩家支持** - 获取任何曾经进入过服务器的玩家头颅（无需在线）&#10;-  **UUID 稳定性** - 基于 UUID 生成，玩家改名后仍然有效&#10;-  **丰富的颜色支持** - 支持 16 进制颜色代码和传统颜色代码&#10;-  **智能物品给予** - 背包满时自动掉落到脚下，不会丢失&#10;- ⚡ **热重载配置** - 无需重启服务器即可重载配置&#10;- ️ **安全保护** - 防止生成的头颅在铁砧中被修改&#10;&#10;##  快速开始&#10;&#10;### 安装要求&#10;- Minecraft 服务器版本：1.21+&#10;- Java 版本：17+&#10;- 服务端类型：Bukkit/Spigot/Paper/Folia&#10;&#10;### 安装步骤&#10;1. 将 `TSL_head-1.0.jar` 文件放入服务器的 `plugins` 文件夹&#10;2. 重启服务器或使用 `/reload` 命令&#10;3. 插件将自动生成默认配置文件&#10;&#10;##  使用方法&#10;&#10;### 基本命令&#10;&#10;```bash&#10;# 获取头颅给自己&#10;/thead &lt;类型&gt; &lt;玩家名&gt;&#10;&#10;# 获取头颅给指定玩家&#10;/thead &lt;类型&gt; &lt;玩家名&gt; &lt;接收玩家&gt;&#10;&#10;# 重载配置&#10;/thead reload&#10;```&#10;&#10;### 命令别名&#10;- `/TSL_head` - 主命令&#10;- `/thead` - 简短别名&#10;&#10;### 使用示例&#10;&#10;```bash&#10;# 给自己获取 Steve 的 SSR 头颅&#10;/thead SSR Steve&#10;&#10;# 给 Alice 一个 Notch 的 R 头颅&#10;/thead R Notch Alice&#10;&#10;# 获取离线玩家的头颅&#10;/thead SSR OldPlayer&#10;&#10;# 重载插件配置&#10;/thead reload&#10;```&#10;&#10;## ⚙️ 配置文件&#10;&#10;### config.yml 配置&#10;&#10;```yaml&#10;SSR:&#10;  name: &quot;&amp;#d9afd9[SSR] {Player_name}&quot;&#10;  lore:&#10;    - &quot;第一行描述&quot;&#10;    - &quot;第二行描述&quot;&#10;&#10;R:&#10;  name: &quot;&amp;#a1cfff[R] {Player_name}&quot;&#10;  lore:&#10;    - &quot;第一行描述&quot;&#10;    - &quot;第二行描述&quot;&#10;&#10;# 添加更多稀有度等级...&#10;SR:&#10;  name: &quot;&amp;#ffb347[SR] {Player_name}&quot;&#10;  lore:&#10;    - &quot;稀有头颅&quot;&#10;    - &quot;收集价值很高&quot;&#10;&#10;N:&#10;  name: &quot;&amp;7[N] {Player_name}&quot;&#10;  lore:&#10;    - &quot;普通头颅&quot;&#10;```&#10;&#10;### 配置说明&#10;&#10;- **类型名称**：配置文件中的键名（如 `SSR`、`R`）&#10;- **name**：头颅的显示名称模板&#10;- **lore**：头颅的描述文本列表&#10;- **{Player_name}**：会被替换为实际的玩家名称&#10;&#10;### 颜色代码支持&#10;&#10;| 格式 | 示例 | 说明 |&#10;|------|------|------|&#10;| 16进制 | `&amp;#ff0000` | 红色 |&#10;| 传统代码 | `&amp;c` | 红色 |&#10;| 组合使用 | `&amp;#d9afd9&amp;l[SSR]` | 粉紫色加粗 |&#10;&#10;##  权限设置&#10;&#10;### 权限节点&#10;&#10;| 权限 | 描述 | 默认 |&#10;|------|------|------|&#10;| `tslhead.use` | 允许使用 TSL_head 命令 | OP |&#10;&#10;### 权限配置示例&#10;&#10;```yaml&#10;# 在权限插件中配置&#10;permissions:&#10;  tslhead.use:&#10;    description: 允许使用头颅命令&#10;    default: op  # 或者设置为 true 给所有玩家&#10;```&#10;&#10;##  特殊功能&#10;&#10;### 离线玩家支持&#10;- ✅ 支持获取离线玩家头颅&#10;- ✅ 基于 UUID 确保皮肤正确显示&#10;- ✅ 玩家改名后仍然有效&#10;- ❌ 不支持从未进入过服务器的玩家&#10;&#10;### 智能物品给予&#10;- 背包有空间 → 直接放入背包&#10;- 背包已满 → 自动掉落到玩家脚下&#10;- 显示相应的提示信息&#10;&#10;### 防修改保护&#10;- 生成的头颅无法在铁砧中重命名&#10;- 保护头颅的特殊属性不被篡改&#10;&#10;##  使用场景&#10;&#10;### 适用服务器类型&#10;- **RPG 服务器** - 稀有度收集系统&#10;- **PVP 服务器** - 击杀奖励头颅&#10;- **生存服务器** - 玩家纪念品收集&#10;- **小游戏服务器** - 胜利奖励展示&#10;&#10;### 实际应用示例&#10;&#10;```bash&#10;# 管理员奖励系统&#10;/thead SSR WinnerPlayer RewardReceiver&#10;&#10;# 玩家自主收集&#10;/thead R FriendName&#10;&#10;# 纪念离线朋友&#10;/thead SR OldFriend&#10;```&#10;&#10;## ️ 开发信息&#10;&#10;### 技术特性&#10;- **API 版本**：1.21&#10;- **Folia 兼容**：✅ 支持&#10;- **异步安全**：✅ 支持&#10;- **热重载**：✅ 支持&#10;&#10;### 依赖关系&#10;- 无外部依赖&#10;- 纯 Bukkit API 实现&#10;&#10;##  更新日志&#10;&#10;### v1.0 (当前版本)&#10;- ✨ 初始版本发布&#10;- ✨ 支持自定义头颅类型配置&#10;- ✨ 离线玩家头颅获取&#10;- ✨ 智能物品给予系统&#10;- ✨ 16进制颜色支持&#10;- ✨ 防修改保护&#10;- ✨ Tab 自动补全&#10;&#10;##  故障排除&#10;&#10;### 常见问题&#10;&#10;**Q: 无法获取离线玩家头颅？**&#10;A: 确保该玩家至少进入过一次服务器，插件需要服务器缓存的 UUID 数据。&#10;&#10;**Q: 头颅没有皮肤？**&#10;A: 检查服务器是否为正版验证，盗版服务器可能无法正确显示皮肤。&#10;&#10;**Q: 配置修改后不生效？**&#10;A: 使用 `/thead reload` 命令重载配置，或重启服务器。&#10;&#10;**Q: 没有权限使用命令？**&#10;A: 确保玩家拥有 `tslhead.use` 权限。&#10;&#10;### 错误消息说明&#10;&#10;| 消息 | 原因 | 解决方法 |&#10;|------|------|----------|&#10;| &quot;玩家从未进入过服务器&quot; | 目标玩家未在服务器注册 | 检查玩家名拼写或等待玩家进入 |&#10;| &quot;接收玩家不在线&quot; | 接收者离线 | 确保接收玩家在线 |&#10;| &quot;未找到命名&quot; | 配置中不存在该类型 | 检查配置文件或使用正确的类型名 |&#10;&#10;##  支持与反馈&#10;&#10;如果您在使用过程中遇到问题或有改进建议，请：&#10;&#10;1. 检查此 README 的故障排除部分&#10;2. 确认使用的是最新版本&#10;3. 联系服务器管理员或插件作者&#10;&#10;---&#10;&#10;**作者**: Zvbj  &#10;**版本**: 1.0  &#10;**兼容**: Minecraft 1.21+ | Bukkit/Spigot/Paper/Folia&#10;" />
              <option name="updatedContent" value="# TSLhead - 玩家头颅插件&#10;&#10;![Version](https://img.shields.io/badge/version-1.0-blue.svg)&#10;![Minecraft](https://img.shields.io/badge/minecraft-1.21-green.svg)&#10;![Folia](https://img.shields.io/badge/folia-supported-orange.svg)&#10;&#10;一个用于 Minecraft 服务器的自定义玩家头颅生成插件，支持稀有度系统和离线玩家头颅获取。&#10;&#10;## ✨ 主要功能&#10;&#10;-  **自定义头颅生成** - 根据配置创建带有自定义名称和描述的玩家头颅&#10;-  **离线玩家支持** - 获取任何曾经进入过服务器的玩家头颅（无需在线）&#10;-  **UUID 稳定性** - 基于 UUID 生成，玩家改名后仍然有效&#10;-  **丰富的颜色支持** - 支持 16 进制颜色代码和传统颜色代码&#10;-  **智能物品给予** - 背包满时自动掉落到脚下，不会丢失&#10;- ⚡ **热重载配置** - 无需重启服务器即可重载配置&#10;- ️ **安全保护** - 防止生成的头颅在铁砧中被修改&#10;&#10;##  快速开始&#10;&#10;### 安装要求&#10;- Minecraft 服务器版本：1.21+&#10;- Java 版本：17+&#10;- 服务端类型：Bukkit/Spigot/Paper/Folia&#10;&#10;### 安装步骤&#10;1. 将 `TSLhead-1.0.jar` 文件放入服务器的 `plugins` 文件夹&#10;2. 重启服务器或使用 `/reload` 命令&#10;3. 插件将自动生成默认配置文件&#10;&#10;##  使用方法&#10;&#10;### 基本命令&#10;&#10;```bash&#10;# 获取头颅给自己&#10;/thead &lt;类型&gt; &lt;玩家名&gt;&#10;&#10;# 获取头颅给指定玩家&#10;/thead &lt;类型&gt; &lt;玩家名&gt; &lt;接收玩家&gt;&#10;&#10;# 重载配置&#10;/thead reload&#10;```&#10;&#10;### 命令别名&#10;- `/TSLhead` - 主命令&#10;- `/thead` - 简短别名&#10;&#10;### 使用示例&#10;&#10;```bash&#10;# 给自己获取 Steve 的 SSR 头颅&#10;/thead SSR Steve&#10;&#10;# 给 Alice 一个 Notch 的 R 头颅&#10;/thead R Notch Alice&#10;&#10;# 获取离线玩家的头颅&#10;/thead SSR OldPlayer&#10;&#10;# 重载插件配置&#10;/thead reload&#10;```&#10;&#10;## ⚙️ 配置文件&#10;&#10;### config.yml 配置&#10;&#10;```yaml&#10;SSR:&#10;  name: &quot;&amp;#d9afd9[SSR] {Player_name}&quot;&#10;  lore:&#10;    - &quot;第一行描述&quot;&#10;    - &quot;第二行描述&quot;&#10;&#10;R:&#10;  name: &quot;&amp;#a1cfff[R] {Player_name}&quot;&#10;  lore:&#10;    - &quot;第一行描述&quot;&#10;    - &quot;第二行描述&quot;&#10;&#10;# 添加更多稀有度等级...&#10;SR:&#10;  name: &quot;&amp;#ffb347[SR] {Player_name}&quot;&#10;  lore:&#10;    - &quot;稀有头颅&quot;&#10;    - &quot;收集价值很高&quot;&#10;&#10;N:&#10;  name: &quot;&amp;7[N] {Player_name}&quot;&#10;  lore:&#10;    - &quot;普通头颅&quot;&#10;```&#10;&#10;### 配置说明&#10;&#10;- **类型名称**：配置文件中的键名（如 `SSR`、`R`）&#10;- **name**：头颅的显示名称模板&#10;- **lore**：头颅的描述文本列表&#10;- **{Player_name}**：会被替换为实际的玩家名称&#10;&#10;### 颜色代码支持&#10;&#10;| 格式 | 示例 | 说明 |&#10;|------|------|------|&#10;| 16进制 | `&amp;#ff0000` | 红色 |&#10;| 传统代码 | `&amp;c` | 红色 |&#10;| 组合使用 | `&amp;#d9afd9&amp;l[SSR]` | 粉紫色加粗 |&#10;&#10;##  权限设置&#10;&#10;### 权限节点&#10;&#10;| 权限 | 描述 | 默认 |&#10;|------|------|------|&#10;| `tslhead.use` | 允许使用 TSLhead 命令 | OP |&#10;&#10;### 权限配置示例&#10;&#10;```yaml&#10;# 在权限插件中配置&#10;permissions:&#10;  tslhead.use:&#10;    description: 允许使用头颅命令&#10;    default: op  # 或者设置为 true 给所有玩家&#10;```&#10;&#10;##  特殊功能&#10;&#10;### 离线玩家支持&#10;- ✅ 支持获取离线玩家头颅&#10;- ✅ 基于 UUID 确保皮肤正确显示&#10;- ✅ 玩家改名后仍然有效&#10;- ❌ 不支持从未进入过服务器的玩家&#10;&#10;### 智能物品给予&#10;- 背包有空间 → 直接放入背包&#10;- 背包已满 → 自动掉落到玩家脚下&#10;- 显示相应的提示信息&#10;&#10;### 防修改保护&#10;- 生成的头颅无法在铁砧中重命名&#10;- 保护头颅的特殊属性不被篡改&#10;&#10;##  使用场景&#10;&#10;### 适用服务器类型&#10;- **RPG 服务器** - 稀有度收集系统&#10;- **PVP 服务器** - 击杀奖励头颅&#10;- **生存服务器** - 玩家纪念品收集&#10;- **小游戏服务器** - 胜利奖励展示&#10;&#10;### 实际应用示例&#10;&#10;```bash&#10;# 管理员奖励系统&#10;/thead SSR WinnerPlayer RewardReceiver&#10;&#10;# 玩家自主收集&#10;/thead R FriendName&#10;&#10;# 纪念离线朋友&#10;/thead SR OldFriend&#10;```&#10;&#10;## ️ 开发信息&#10;&#10;### 技术特性&#10;- **API 版本**：1.21&#10;- **Folia 兼容**：✅ 支持&#10;- **异步安全**：✅ 支持&#10;- **热重载**：✅ 支持&#10;&#10;### 依赖关系&#10;- 无外部依赖&#10;- 纯 Bukkit API 实现&#10;&#10;##  更新日志&#10;&#10;### v1.0 (当前版本)&#10;- ✨ 初始版本发布&#10;- ✨ 支持自定义头颅类型配置&#10;- ✨ 离线玩家头颅获取&#10;- ✨ 智能物品给予系统&#10;- ✨ 16进制颜色支持&#10;- ✨ 防修改保护&#10;- ✨ Tab 自动补全&#10;&#10;##  故障排除&#10;&#10;### 常见问题&#10;&#10;**Q: 无法获取离线玩家头颅？**&#10;A: 确保该玩家至少进入过一次服务器，插件需要服务器缓存的 UUID 数据。&#10;&#10;**Q: 头颅没有皮肤？**&#10;A: 检查服务器是否为正版验证，盗版服务器可能无法正确显示皮肤。&#10;&#10;**Q: 配置修改后不生效？**&#10;A: 使用 `/thead reload` 命令重载配置，或重启服务器。&#10;&#10;**Q: 没有权限使用命令？**&#10;A: 确保玩家拥有 `tslhead.use` 权限。&#10;&#10;### 错误消息说明&#10;&#10;| 消息 | 原因 | 解决方法 |&#10;|------|------|----------|&#10;| &quot;玩家从未进入过服务器&quot; | 目标玩家未在服务器注册 | 检查玩家名拼写或等待玩家进入 |&#10;| &quot;接收玩家不在线&quot; | 接收者离线 | 确保接收玩家在线 |&#10;| &quot;未找到命名&quot; | 配置中不存在该类型 | 检查配置文件或使用正确的类型名 |&#10;&#10;##  支持与反馈&#10;&#10;如果您在使用过程中遇到问题或有改进建议，请：&#10;&#10;1. 检查此 README 的故障排除部分&#10;2. 确认使用的是最新版本&#10;3. 联系服务器管理员或插件作者&#10;&#10;---&#10;&#10;**作者**: Zvbj  &#10;**版本**: 1.0  &#10;**兼容**: Minecraft 1.21+ | Bukkit/Spigot/Paper/Folia" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main/java/com/zvbj/TSL_head/HeadCommand.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/java/com/zvbj/TSL_head/HeadCommand.java" />
              <option name="originalContent" value="package com.zvbj.TSL_head;&#10;&#10;import org.bukkit.Bukkit;&#10;import org.bukkit.ChatColor;&#10;import org.bukkit.OfflinePlayer;&#10;import org.bukkit.command.*;&#10;import org.bukkit.entity.Player;&#10;import org.bukkit.inventory.ItemStack;&#10;import org.bukkit.inventory.meta.SkullMeta;&#10;&#10;import java.util.*;&#10;import java.util.regex.Matcher;&#10;import java.util.regex.Pattern;&#10;import java.util.stream.Collectors;&#10;&#10;public class HeadCommand implements CommandExecutor, TabCompleter {&#10;    private final ConfigManager configManager;&#10;    private static final Pattern HEX_PATTERN = Pattern.compile(&quot;&amp;#([A-Fa-f0-9]{6})&quot;);&#10;&#10;    public HeadCommand(ConfigManager configManager) {&#10;        this.configManager = configManager;&#10;    }&#10;&#10;    @Override&#10;    public boolean onCommand(CommandSender sender, Command cmd, String label, String[] args) {&#10;        if (!sender.hasPermission(&quot;tslhead.use&quot;)) {&#10;            sender.sendMessage(ChatColor.RED + &quot;你没有权限执行此命令&quot;);&#10;            return true;&#10;        }&#10;&#10;        if (args.length == 1 &amp;&amp; args[0].equalsIgnoreCase(&quot;reload&quot;)) {&#10;            configManager.loadConfigs();&#10;            sender.sendMessage(ChatColor.GREEN + &quot;TSL_head 配置已重新加载&quot;);&#10;            return true;&#10;        }&#10;&#10;        // 支持2个参数（默认给自己）或3个参数的情况&#10;        if (args.length == 2 || args.length == 3) {&#10;            String key = args[0];&#10;            SkullConfig sc = configManager.getConfig(key);&#10;            if (sc == null) {&#10;                sender.sendMessage(ChatColor.RED + &quot;未找到命名: &quot; + key);&#10;                return true;&#10;            }&#10;&#10;            // 使用OfflinePlayer来支持离线玩家&#10;            OfflinePlayer target = Bukkit.getOfflinePlayer(args[1]);&#10;            Player receiver;&#10;&#10;            // 如果只有2个参数，接收者默认为命令发送者&#10;            if (args.length == 2) {&#10;                if (!(sender instanceof Player)) {&#10;                    sender.sendMessage(ChatColor.RED + &quot;控制台必须指定接收玩家&quot;);&#10;                    return true;&#10;                }&#10;                receiver = (Player) sender;&#10;            } else {&#10;                // 3个参数的情况，使用指定的接收者&#10;                receiver = Bukkit.getPlayerExact(args[2]);&#10;            }&#10;&#10;            // 检查目标玩家是否曾经进过服务器&#10;            if (!target.hasPlayedBefore() &amp;&amp; !target.isOnline()) {&#10;                sender.sendMessage(ChatColor.RED + &quot;玩家 &quot; + args[1] + &quot; 从未进入过服务器&quot;);&#10;                return true;&#10;            }&#10;&#10;            // 检查接收者是否在线&#10;            if (receiver == null) {&#10;                sender.sendMessage(ChatColor.RED + &quot;接收玩家 &quot; + args[2] + &quot; 不在线&quot;);&#10;                return true;&#10;            }&#10;&#10;            // 创建头颅物品&#10;            ItemStack skull = new ItemStack(org.bukkit.Material.PLAYER_HEAD);&#10;            SkullMeta meta = (SkullMeta) skull.getItemMeta();&#10;            if (meta != null) {&#10;                // 使用UUID设置头颅所有者，这样即使玩家离线也能正确显示皮肤&#10;                meta.setOwningPlayer(target);&#10;&#10;                // 获取玩家名字（优先使用真实名字，如果离线则使用输入的名字）&#10;                String playerName = target.getName() != null ? target.getName() : args[1];&#10;&#10;                String name = format(sc.getNameTemplate(), playerName);&#10;                meta.setDisplayName(name);&#10;                List&lt;String&gt; lore = sc.getLoreTemplate().stream()&#10;                        .map(line -&gt; format(line, playerName))&#10;                        .collect(Collectors.toList());&#10;                meta.setLore(lore);&#10;                skull.setItemMeta(meta);&#10;            }&#10;&#10;            // 尝试将头颅添加到玩家背包，如果背包满了则掉落到地上&#10;            HashMap&lt;Integer, ItemStack&gt; leftover = receiver.getInventory().addItem(skull);&#10;&#10;            // 检查是否有剩余物品（背包满了）&#10;            if (!leftover.isEmpty()) {&#10;                // 背包满了，将头颅掉落到玩家脚下&#10;                for (ItemStack item : leftover.values()) {&#10;                    receiver.getWorld().dropItemNaturally(receiver.getLocation(), item);&#10;                }&#10;                sender.sendMessage(ChatColor.YELLOW + &quot;玩家 &quot; + receiver.getName() + &quot; 的背包已满，头颅已掉落到其脚下&quot;);&#10;            }&#10;&#10;            String targetStatus = target.isOnline() ? &quot;在线&quot; : &quot;离线&quot;;&#10;            sender.sendMessage(ChatColor.GREEN + &quot;已将 &quot; + args[1] + &quot; (&quot; + targetStatus + &quot;) 的头颅 (&quot; + key + &quot;) 给予 &quot; + receiver.getName());&#10;            return true;&#10;        }&#10;&#10;        sender.sendMessage(ChatColor.YELLOW + &quot;用法: /thead reload OR /thead &lt;命名&gt; &lt;玩家名&gt; [接收玩家]&quot;);&#10;        return true;&#10;    }&#10;&#10;    private String format(String template, String playerName) {&#10;        String replaced = template.replace(&quot;{Player_name}&quot;, playerName);&#10;        String withHex = applyHexColors(replaced);&#10;        return ChatColor.translateAlternateColorCodes('&amp;', withHex);&#10;    }&#10;&#10;    private String applyHexColors(String input) {&#10;        Matcher matcher = HEX_PATTERN.matcher(input);&#10;        StringBuffer sb = new StringBuffer();&#10;        while (matcher.find()) {&#10;            String hex = matcher.group(1);&#10;            String legacy = toLegacy(hex);&#10;            matcher.appendReplacement(sb, legacy);&#10;        }&#10;        matcher.appendTail(sb);&#10;        return sb.toString();&#10;    }&#10;&#10;    private String toLegacy(String hex) {&#10;        char[] chars = hex.toCharArray();&#10;        StringBuilder sb = new StringBuilder(&quot;§x&quot;);&#10;        for (char c : chars) {&#10;            sb.append('§').append(c);&#10;        }&#10;        return sb.toString();&#10;    }&#10;&#10;    @Override&#10;    public List&lt;String&gt; onTabComplete(CommandSender sender, Command cmd, String alias, String[] args) {&#10;        if (args.length == 1) {&#10;            List&lt;String&gt; completions = new ArrayList&lt;&gt;(Arrays.asList(&quot;reload&quot;));&#10;            completions.addAll(configManager.getKeys().stream()&#10;                    .filter(k -&gt; k.toLowerCase().startsWith(args[0].toLowerCase()))&#10;                    .collect(Collectors.toList()));&#10;            return completions;&#10;        }&#10;&#10;        if (args.length == 2) {&#10;            // 为目标玩家提供补全：在线玩家 + 最近离线的玩家&#10;            List&lt;String&gt; suggestions = new ArrayList&lt;&gt;();&#10;&#10;            // 添加在线玩家&#10;            suggestions.addAll(Bukkit.getOnlinePlayers().stream()&#10;                    .map(Player::getName)&#10;                    .filter(n -&gt; n.toLowerCase().startsWith(args[1].toLowerCase()))&#10;                    .collect(Collectors.toList()));&#10;&#10;            // 添加离线玩家（限制数量避免过多建议）&#10;            suggestions.addAll(Arrays.stream(Bukkit.getOfflinePlayers())&#10;                    .filter(p -&gt; p.getName() != null &amp;&amp; p.hasPlayedBefore())&#10;                    .map(OfflinePlayer::getName)&#10;                    .filter(n -&gt; n.toLowerCase().startsWith(args[1].toLowerCase()))&#10;                    .limit(10) // 限制离线玩家建议数量&#10;                    .collect(Collectors.toList()));&#10;&#10;            return suggestions.stream().distinct().collect(Collectors.toList());&#10;        }&#10;&#10;        if (args.length == 3) {&#10;            // 接收玩家只能是在线玩家&#10;            return Bukkit.getOnlinePlayers().stream()&#10;                    .map(Player::getName)&#10;                    .filter(n -&gt; n.toLowerCase().startsWith(args[2].toLowerCase()))&#10;                    .collect(Collectors.toList());&#10;        }&#10;&#10;        return Collections.emptyList();&#10;    }&#10;}" />
              <option name="updatedContent" value="package com.zvbj.TSL_head;&#10;&#10;import org.bukkit.Bukkit;&#10;import org.bukkit.ChatColor;&#10;import org.bukkit.OfflinePlayer;&#10;import org.bukkit.command.*;&#10;import org.bukkit.entity.Player;&#10;import org.bukkit.inventory.ItemStack;&#10;import org.bukkit.inventory.meta.SkullMeta;&#10;&#10;import java.util.*;&#10;import java.util.regex.Matcher;&#10;import java.util.regex.Pattern;&#10;import java.util.stream.Collectors;&#10;&#10;public class HeadCommand implements CommandExecutor, TabCompleter {&#10;    private final ConfigManager configManager;&#10;    private static final Pattern HEX_PATTERN = Pattern.compile(&quot;&amp;#([A-Fa-f0-9]{6})&quot;);&#10;&#10;    public HeadCommand(ConfigManager configManager) {&#10;        this.configManager = configManager;&#10;    }&#10;&#10;    @Override&#10;    public boolean onCommand(CommandSender sender, Command cmd, String label, String[] args) {&#10;        if (!sender.hasPermission(&quot;tslhead.use&quot;)) {&#10;            sender.sendMessage(ChatColor.RED + &quot;你没有权限执行此命令&quot;);&#10;            return true;&#10;        }&#10;&#10;        if (args.length == 1 &amp;&amp; args[0].equalsIgnoreCase(&quot;reload&quot;)) {&#10;            configManager.loadConfigs();&#10;            sender.sendMessage(ChatColor.GREEN + &quot;TSLhead 配置已重新加载&quot;);&#10;            return true;&#10;        }&#10;&#10;        // 支持2个参数（默认给自己）或3个参数的情况&#10;        if (args.length == 2 || args.length == 3) {&#10;            String key = args[0];&#10;            SkullConfig sc = configManager.getConfig(key);&#10;            if (sc == null) {&#10;                sender.sendMessage(ChatColor.RED + &quot;未找到命名: &quot; + key);&#10;                return true;&#10;            }&#10;&#10;            // 使用OfflinePlayer来支持离线玩家&#10;            OfflinePlayer target = Bukkit.getOfflinePlayer(args[1]);&#10;            Player receiver;&#10;&#10;            // 如果只有2个参数，接收者默认为命令发送者&#10;            if (args.length == 2) {&#10;                if (!(sender instanceof Player)) {&#10;                    sender.sendMessage(ChatColor.RED + &quot;控制台必须指定接收玩家&quot;);&#10;                    return true;&#10;                }&#10;                receiver = (Player) sender;&#10;            } else {&#10;                // 3个参数的情况，使用指定的接收者&#10;                receiver = Bukkit.getPlayerExact(args[2]);&#10;            }&#10;&#10;            // 检查目标玩家是否曾经进过服务器&#10;            if (!target.hasPlayedBefore() &amp;&amp; !target.isOnline()) {&#10;                sender.sendMessage(ChatColor.RED + &quot;玩家 &quot; + args[1] + &quot; 从未进入过服务器&quot;);&#10;                return true;&#10;            }&#10;&#10;            // 检查接收者是否在线&#10;            if (receiver == null) {&#10;                sender.sendMessage(ChatColor.RED + &quot;接收玩家 &quot; + args[2] + &quot; 不在线&quot;);&#10;                return true;&#10;            }&#10;&#10;            // 创建头颅物品&#10;            ItemStack skull = new ItemStack(org.bukkit.Material.PLAYER_HEAD);&#10;            SkullMeta meta = (SkullMeta) skull.getItemMeta();&#10;            if (meta != null) {&#10;                // 使用UUID设置头颅所有者，这样即使玩家离线也能正确显示皮肤&#10;                meta.setOwningPlayer(target);&#10;&#10;                // 获取玩家名字（优先使用真实名字，如果离线则使用输入的名字）&#10;                String playerName = target.getName() != null ? target.getName() : args[1];&#10;&#10;                String name = format(sc.getNameTemplate(), playerName);&#10;                meta.setDisplayName(name);&#10;                List&lt;String&gt; lore = sc.getLoreTemplate().stream()&#10;                        .map(line -&gt; format(line, playerName))&#10;                        .collect(Collectors.toList());&#10;                meta.setLore(lore);&#10;                skull.setItemMeta(meta);&#10;            }&#10;&#10;            // 尝试将头颅添加到玩家背包，如果背包满了则掉落到地上&#10;            HashMap&lt;Integer, ItemStack&gt; leftover = receiver.getInventory().addItem(skull);&#10;&#10;            // 检查是否有剩余物品（背包满了）&#10;            if (!leftover.isEmpty()) {&#10;                // 背包满了，将头颅掉落到玩家脚下&#10;                for (ItemStack item : leftover.values()) {&#10;                    receiver.getWorld().dropItemNaturally(receiver.getLocation(), item);&#10;                }&#10;                sender.sendMessage(ChatColor.YELLOW + &quot;玩家 &quot; + receiver.getName() + &quot; 的背包已满，头颅已掉落到其脚下&quot;);&#10;            }&#10;&#10;            String targetStatus = target.isOnline() ? &quot;在线&quot; : &quot;离线&quot;;&#10;            sender.sendMessage(ChatColor.GREEN + &quot;已将 &quot; + args[1] + &quot; (&quot; + targetStatus + &quot;) 的头颅 (&quot; + key + &quot;) 给予 &quot; + receiver.getName());&#10;            return true;&#10;        }&#10;&#10;        sender.sendMessage(ChatColor.YELLOW + &quot;用法: /thead reload OR /thead &lt;命名&gt; &lt;玩家名&gt; [接收玩家]&quot;);&#10;        return true;&#10;    }&#10;&#10;    private String format(String template, String playerName) {&#10;        String replaced = template.replace(&quot;{Player_name}&quot;, playerName);&#10;        String withHex = applyHexColors(replaced);&#10;        return ChatColor.translateAlternateColorCodes('&amp;', withHex);&#10;    }&#10;&#10;    private String applyHexColors(String input) {&#10;        Matcher matcher = HEX_PATTERN.matcher(input);&#10;        StringBuffer sb = new StringBuffer();&#10;        while (matcher.find()) {&#10;            String hex = matcher.group(1);&#10;            String legacy = toLegacy(hex);&#10;            matcher.appendReplacement(sb, legacy);&#10;        }&#10;        matcher.appendTail(sb);&#10;        return sb.toString();&#10;    }&#10;&#10;    private String toLegacy(String hex) {&#10;        char[] chars = hex.toCharArray();&#10;        StringBuilder sb = new StringBuilder(&quot;§x&quot;);&#10;        for (char c : chars) {&#10;            sb.append('§').append(c);&#10;        }&#10;        return sb.toString();&#10;    }&#10;&#10;    @Override&#10;    public List&lt;String&gt; onTabComplete(CommandSender sender, Command cmd, String alias, String[] args) {&#10;        if (args.length == 1) {&#10;            List&lt;String&gt; completions = new ArrayList&lt;&gt;(Arrays.asList(&quot;reload&quot;));&#10;            completions.addAll(configManager.getKeys().stream()&#10;                    .filter(k -&gt; k.toLowerCase().startsWith(args[0].toLowerCase()))&#10;                    .collect(Collectors.toList()));&#10;            return completions;&#10;        }&#10;&#10;        if (args.length == 2) {&#10;            // 为目标玩家提供补全：在线玩家 + 最近离线的玩家&#10;            List&lt;String&gt; suggestions = new ArrayList&lt;&gt;();&#10;&#10;            // 添加在线玩家&#10;            suggestions.addAll(Bukkit.getOnlinePlayers().stream()&#10;                    .map(Player::getName)&#10;                    .filter(n -&gt; n.toLowerCase().startsWith(args[1].toLowerCase()))&#10;                    .collect(Collectors.toList()));&#10;&#10;            // 添加离线玩家（限制数量避免过多建议）&#10;            suggestions.addAll(Arrays.stream(Bukkit.getOfflinePlayers())&#10;                    .filter(p -&gt; p.getName() != null &amp;&amp; p.hasPlayedBefore())&#10;                    .map(OfflinePlayer::getName)&#10;                    .filter(n -&gt; n.toLowerCase().startsWith(args[1].toLowerCase()))&#10;                    .limit(10) // 限制离线玩家建议数量&#10;                    .collect(Collectors.toList()));&#10;&#10;            return suggestions.stream().distinct().collect(Collectors.toList());&#10;        }&#10;&#10;        if (args.length == 3) {&#10;            // 接收玩家只能是在线玩家&#10;            return Bukkit.getOnlinePlayers().stream()&#10;                    .map(Player::getName)&#10;                    .filter(n -&gt; n.toLowerCase().startsWith(args[2].toLowerCase()))&#10;                    .collect(Collectors.toList());&#10;        }&#10;&#10;        return Collections.emptyList();&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main/java/com/zvbj/TSL_head/TSL_Head.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/java/com/zvbj/TSL_head/TSL_Head.java" />
              <option name="originalContent" value="package com.zvbj.TSL_head;&#10;&#10;import org.bukkit.plugin.java.JavaPlugin;&#10;&#10;public class TSL_Head extends JavaPlugin {&#10;    private ConfigManager configManager;&#10;&#10;    @Override&#10;    public void onEnable() {&#10;        saveDefaultConfig();&#10;        configManager = new ConfigManager(this);&#10;        HeadCommand command = new HeadCommand(configManager);&#10;        getCommand(&quot;TSL_head&quot;).setExecutor(command);&#10;        getCommand(&quot;TSL_head&quot;).setTabCompleter(command);&#10;        getServer().getPluginManager().registerEvents(new AnvilListener(), this);&#10;        getLogger().info(&quot;TSL_head 已启用&quot;);&#10;    }&#10;&#10;    @Override&#10;    public void onDisable() {&#10;        getLogger().info(&quot;TSL_head 已禁用&quot;);&#10;    }&#10;}" />
              <option name="updatedContent" value="package com.zvbj.TSL_head;&#10;&#10;import org.bukkit.plugin.java.JavaPlugin;&#10;&#10;public class TSL_Head extends JavaPlugin {&#10;    private ConfigManager configManager;&#10;&#10;    @Override&#10;    public void onEnable() {&#10;        saveDefaultConfig();&#10;        configManager = new ConfigManager(this);&#10;        HeadCommand command = new HeadCommand(configManager);&#10;        getCommand(&quot;TSLhead&quot;).setExecutor(command);&#10;        getCommand(&quot;TSLhead&quot;).setTabCompleter(command);&#10;        getServer().getPluginManager().registerEvents(new AnvilListener(), this);&#10;        getLogger().info(&quot;TSLhead 已启用&quot;);&#10;    }&#10;&#10;    @Override&#10;    public void onDisable() {&#10;        getLogger().info(&quot;TSLhead 已禁用&quot;);&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main/resources/plugin.yml">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/resources/plugin.yml" />
              <option name="originalContent" value="name: TSLhead&#10;version: '1.0'&#10;main: com.zvbj.TSL_head.TSL_Head&#10;api-version: '1.21'&#10;authors: [ Zvbj ]&#10;description: TSL服务器の插件 - 支持在线/离线玩家头颅获取&#10;folia-supported: true&#10;commands:&#10;  TSL_head:&#10;    description: 获取玩家头颅（支持离线玩家）&#10;    aliases: [thead]&#10;    usage: /&lt;command&gt; reload OR /&lt;command&gt; &lt;命名&gt; &lt;玩家名&gt; [接收玩家]&#10;    permission: tslhead.use&#10;&#10;permissions:&#10;  tslhead.use:&#10;    description: 允许使用 TSL_head 命令&#10;    default: op" />
              <option name="updatedContent" value="name: TSLhead&#10;version: '1.0'&#10;main: com.zvbj.TSL_head.TSL_Head&#10;api-version: '1.21'&#10;authors: [ Zvbj ]&#10;description: TSL服务器の插件 - 支持在线/离线玩家头颅获取&#10;folia-supported: true&#10;commands:&#10;  TSLhead:&#10;    description: 获取玩家头颅（支持离线玩家）&#10;    aliases: [thead]&#10;    usage: /&lt;command&gt; reload OR /&lt;command&gt; &lt;命名&gt; &lt;玩家名&gt; [接收玩家]&#10;    permission: tslhead.use&#10;&#10;permissions:&#10;  tslhead.use:&#10;    description: 允许使用 TSLhead 命令&#10;    default: op" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>